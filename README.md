# CavesBasic ê°œì¸ í”„ë¡œì íŠ¸
## ğŸ® í”„ë¡œì íŠ¸ ê°œìš”
| í•­ëª©        | ë‚´ìš©                              |
|-------------|-----------------------------------|
| **ì¥ë¥´**        | íƒ‘ë‹¤ìš´ íŒíƒ€ì§€ RPG                 |
| **ì»¨ì…‰**        | ì–´ë‘ìš´ ë™êµ´ ì† ì „íˆ¬ì™€ ìƒì¡´         |
| **ëª©í‘œ**        | C++ & Unreal Engine 5.4 ê¸°ë°˜ í•µì‹¬ RPG ì‹œìŠ¤í…œ êµ¬í˜„ |
| **ê¸°ê°„**        | 2024.10.15 ~ 2024.11.15           |
| **ê°œë°œì**      | ì›ì¬ë¯¼                            |

![alt text](README_content/main2.png "Title Text")
![alt text](README_content/main.png "Title Text") <br></br>

---

## ğŸ› ï¸ ê¸°ìˆ  ìŠ¤íƒ
- **ì–¸ì–´** : C++
- **ê²Œì„ ì—”ì§„** : Unreal Engine 5.4
- **ë²„ì „ ê´€ë¦¬** : Sourcetree, GitHub
- **IDE** : Visual Studio 2022

---

## âš¡ ë¹Œë“œ ë° ì‹¤í–‰ ë°©ë²•

1. **í•„ìˆ˜ í™˜ê²½**
   - Unreal Engine 5.4
   - Visual Studio 2022
   - Windows 10/11 64bit

2. **í”„ë¡œì íŠ¸ ë‹¤ìš´ë¡œë“œ**
    ```bash
    git clone https://github.com/WJMcode/Project_CavesBasic.git
    ```

3. **í”„ë¡œì íŠ¸ ì—´ê¸°**
   - `CavesBasic.uproject` ë”ë¸”í´ë¦­ ë˜ëŠ” ì–¸ë¦¬ì–¼ ì—ë””í„°ì—ì„œ ì§ì ‘ ì—´ê¸°

4. **ë¹Œë“œ**
   - `Generate Visual Studio Project files` í›„, Visual Studioì—ì„œ ë¹Œë“œ

5. **ì‹¤í–‰**
   - ì–¸ë¦¬ì–¼ ì—ë””í„°ì—ì„œ `Play` í´ë¦­

---

## âœ¨ ì£¼ìš” ê¸°ëŠ¥ ìš”ì•½

- **Player**
  - 4ë°©í–¥ ì´ë™, ì í”„, ì›…í¬ë¦¬ê¸°, ìŠ¤í‚¬ ì‚¬ìš©(ë¬´ê¸°ë³„)
  - í”¼ê²© ì‹œ ë¬´ì  & ê¹œë¹¡ì„, ì‚¬ë§ ì‹œ ë¦¬ìŠ¤í°
- **Projectile**
  - **Ground Projectile** : ë•… ìœ„ì—ì„œë§Œ ìƒì„±ë˜ëŠ” ë°œì‚¬ì²´ë¡œ, í”Œë ˆì´ì–´ ì „ë°©ì˜ ì§€í˜•ì„ ê°ì§€í•´ ìŠ¤í‚¬ì´ ë™ì‘
  - **Straight Projectile** : ì ì„ ì¶”ì í•˜ëŠ” ì¼ì§ì„  ë°œì‚¬ì²´
- **Monster**
  - ëœë¤ AI ì›€ì§ì„, ì‚¬ë§ ì‹œ íˆ¬ëª…í™” ì—°ì¶œ ë° ì œê±°(ë¨¸í‹°ë¦¬ì–¼ ë™ì  êµì²´, ìì—°ìŠ¤ëŸ¬ìš´ ì‚¬ë§ íš¨ê³¼)
- **UI**
  - í”Œë ˆì´ì–´/ëª¬ìŠ¤í„° ì²´ë ¥ë°”, ì‚¬ë§ ë¦¬ìŠ¤í° ì°½
- **DataTable ê¸°ë°˜ ë°ì´í„° ê´€ë¦¬**  
  - ìºë¦­í„°, ë¬´ê¸°, ìŠ¤í‚¬, íˆ¬ì‚¬ì²´, ì´í™íŠ¸ ë“± í™•ì¥ ê°€ëŠ¥í•œ êµ¬ì¡°, ì—ë””í„°ì—ì„œ ì‹¤ì‹œê°„ ê´€ë¦¬

---

## ğŸ’¡ ì„¤ê³„ í¬ì¸íŠ¸

- **ë°ì´í„° ê¸°ë°˜ êµ¬ì¡°**ë¡œ ì„¤ê³„í•˜ì—¬ ìºë¦­í„°/ëª¬ìŠ¤í„°/ìŠ¤í‚¬ ë“± ë°ì´í„° í™•ì¥ ìš©ì´
- **Blueprint & C++ í˜¼ìš©**ìœ¼ë¡œ ì§ê´€ì„±ê³¼ ì„±ëŠ¥ ëª¨ë‘ í™•ë³´
- **í•˜ë“œì½”ë”© ìµœì†Œí™”**, **ì—ë””í„° ì¹œí™”ì  êµ¬ì¡°**

---

## ğŸ§  í”„ë¡œì íŠ¸ êµ¬ì¡°

```text
Project_CavesBasic/
â”œâ”€â”€ Source/CavesBasic/
â”‚   â”œâ”€â”€ Actors/         # í”Œë ˆì´ì–´, ëª¬ìŠ¤í„° ë“± ì£¼ìš” ì•¡í„°
â”‚   â”œâ”€â”€ Components/     # í”Œë ˆì´ì–´ ìƒíƒœ ë“± ê¸°ëŠ¥ë³„ ì»´í¬ë„ŒíŠ¸
â”‚   â”œâ”€â”€ UI/             # ìœ„ì ¯, HUD
â”‚   â””â”€â”€ GameframeWork/  # GameMode ë“±
â”œâ”€â”€ Config/
â”œâ”€â”€ Content/
â”œâ”€â”€ CavesBasic.uproject
â””â”€â”€ README.md
```
---

## âš ï¸ íŠ¸ëŸ¬ë¸”ìŠˆíŒ…
- **Straight Projectile ì¶”ì  ë¬¸ì œ**
  - **ë¬¸ì œ ë°°ê²½** : Straight Projectileì´ ëª¬ìŠ¤í„° ê°€ê¹Œì´ì—ì„œ ìƒì„±ë  ë•Œ, ëª¬ìŠ¤í„°ë¥¼ ì œëŒ€ë¡œ ì¶”ì í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.
  - **ì›ì¸** : ëª¬ìŠ¤í„°ì˜ ë°©í–¥ì´ ì•„ë‹ˆë¼ ìœ„ì¹˜ë§Œ ì¶”ì í•˜ì—¬, ë°œì‚¬ì²´ê°€ ì˜¬ë°”ë¥´ê²Œ ë”°ë¼ê°€ì§€ ëª»í•œ ê²ƒì´ ì›ì¸ì´ì—ˆìŠµë‹ˆë‹¤.
  - **í•´ê²° ê³¼ì •** : Tickë§ˆë‹¤ ëª¬ìŠ¤í„°ì˜ ë°©í–¥ì„ ì²´í¬í•˜ê³ , ë°œì‚¬ì²´ë¥¼ í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ íšŒì „ì‹œí‚¤ë„ë¡ ìˆ˜ì •í•˜ì˜€ìŠµë‹ˆë‹¤.
  - **ê²°ê³¼** : ë°œì‚¬ì²´ê°€ ëª¬ìŠ¤í„°ë¥¼ ì§€ì†ì ìœ¼ë¡œ ì •í™•íˆ ì¶”ì í•´ ìì—°ìŠ¤ëŸ¬ìš´ íƒ€ê²©ì´ ê°€ëŠ¥í•´ì¡ŒìŠµë‹ˆë‹¤.

- **ëª¬ìŠ¤í„° ì‚¬ë§ ì‹œ íˆ¬ëª…í™” íš¨ê³¼ êµ¬í˜„ ì‹¤íŒ¨**
  - **ë¬¸ì œ ë°°ê²½** : ëª¬ìŠ¤í„° ì‚¬ë§ ì‹œ ì ì  íˆ¬ëª…í•´ì§€ëŠ” íš¨ê³¼ë¥¼ êµ¬í˜„í•˜ë ¤ í–ˆìœ¼ë‚˜, ë¨¸í‹°ë¦¬ì–¼ì˜ Opacity ì¡°ì •ì´ ë¶ˆê°€ëŠ¥í–ˆìŠµë‹ˆë‹¤.
  - **ì›ì¸** : ê¸°ì¡´ ë¨¸í‹°ë¦¬ì–¼ì˜ ë¸”ë Œë“œ ëª¨ë“œê°€ Opaqueë¡œ ì„¤ì •ë˜ì–´ ìˆì—ˆìŠµë‹ˆë‹¤.
  - **ì‹œë„** : Opacityë¥¼ ìˆ˜ì •í•  ìˆ˜ ìˆë„ë¡ ë¸”ë Œë“œ ëª¨ë“œë¥¼ ë°”ê¾¸ì–´ ì ìš©í•˜ì˜€ìœ¼ë‚˜, ëª¬ìŠ¤í„° ì™¸í˜•ì˜ í€„ë¦¬í‹°ê°€ ë–¨ì–´ì¡ŒìŠµë‹ˆë‹¤.
  - **í•´ê²° ê³¼ì •** : ë¸”ë Œë“œ ëª¨ë“œê°€ Translucentì¸ ë¨¸í‹°ë¦¬ì–¼ì„ ë³„ë„ë¡œ ë§Œë“¤ì–´ ì‚¬ë§ ì‹œì—ë§Œ êµì²´í•˜ê³ , Opacity ê°’ì„ ì ì°¨ ë‚®ì¶”ëŠ” ë°©ì‹ìœ¼ë¡œ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤.
  - **ê²°ê³¼** : ëª¬ìŠ¤í„°ê°€ ì‚¬ë§í•  ë•Œ ìì—°ìŠ¤ëŸ½ê²Œ íˆ¬ëª…í•´ì§€ë©° ì‚¬ë¼ì§€ëŠ” íš¨ê³¼ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

---
 
## ğŸ” ì„¸ë¶€ êµ¬í˜„ (ì£¼ìš” ì½”ë“œ/ë¡œì§)

### 1. Player

  - Weaponì„ ìŠµë“í•œ PlayerëŠ” Skill ì‚¬ìš© ê°€ëŠ¥
    
      <details>
        <summary> OnSkill í•¨ìˆ˜ ì½”ë“œ ( Skill ì‹¤í–‰ ì½”ë“œ )</summary>
    
     

    
       ```cpp
       /* Playerê°€ í‚¤ ì…ë ¥ì„ í†µí•´ Skillì„ ì‚¬ìš©í•˜ë©´ OnSkill í•¨ìˆ˜ê°€ í˜¸ì¶œë©ë‹ˆë‹¤.
        * ê¸°ë³¸ì ìœ¼ë¡œ Playerê°€ ì›…í¬ë¦¬ì§€ ì•Šì€ ìƒíƒœì—ì„œë§Œ OnSkill í•¨ìˆ˜ê°€ ì‹¤í–‰ë©ë‹ˆë‹¤.
        * Weaponì€ ì—ë””í„° ë‚´ì— ì¡´ì¬í•˜ëŠ” Weapon ì „ìš© InputMappingContextë¥¼ í†µí•´
        * Skill InputActionë“¤ì„ ë°”ì¸ë”©í•˜ê³  ìˆìŠµë‹ˆë‹¤.
        * OnSkill í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ëŠ” ì‹œì ì— ì–´ë–¤ Skill InputActionì´ ë“¤ì–´ì™”ëŠ”ì§€ ì²´í¬í•©ë‹ˆë‹¤.
        * ( ì´ë•Œ InputAction íŒŒì¼ì˜ ì´ë¦„ ê·œì¹™ì€ "IA_Skill*"ì´ë©° *ì€ 1ë¶€í„° ì‹œì‘í•˜ëŠ” Skill ë²ˆí˜¸ì…ë‹ˆë‹¤. )
        * ì²´í¬í•œ Skill InputActionì˜ ë²ˆí˜¸ë¥¼ í†µí•´ Weapon ë°ì´í„° í…Œì´ë¸”ì´ ì €ì¥í•˜ê³  ìˆëŠ”
        * Skill ë°ì´í„° í…Œì´ë¸”ì˜ í–‰ì— ì ‘ê·¼í•©ë‹ˆë‹¤.
        * Skill ë°ì´í„° í…Œì´ë¸”ì—ëŠ” *ë²ˆ ìŠ¤í‚¬ì´ ì‹¤í–‰ë  ë•Œ ì¬ìƒë˜ëŠ” ëª½íƒ€ì£¼ê°€ ì €ì¥ë˜ì–´ ìˆì–´ í•´ë‹¹ ëª½íƒ€ì£¼ë¥¼ ì¬ìƒí•©ë‹ˆë‹¤.
        */
	void AWeaponBase::OnSkill(const FInputActionInstance& Instance)
	{
	    ACharacter* OwningCharacter = Cast<ACharacter>(OwningPawn);
       	    // ìºë¦­í„°ê°€ ì›…í¬ë¦¬ì§€ ì•Šì€ ìƒíƒœë¼ë©´
	    if (!OwningCharacter->bIsCrouched)
	    {
		// í˜¸ì¶œëœ InputActionì„ í†µí•´ ì–´ë–¤ í‚¤ê°€ ì…ë ¥ë˜ì—ˆëŠ”ì§€ í™•ì¸
		const UInputAction* TriggeredAction = Instance.GetSourceAction();
		FString ActionName = TriggeredAction->GetName();
		// ìŠ¤í‚¬ ë²ˆí˜¸ë§Œ ë‚¨ê¹€
		ActionName.RemoveFromStart(TEXT("IA_Skill"));
		int32 ExecutedSkillNum = FCString::Atoi(*ActionName);
	
		// ì–´ë–¤ í‚¤ê°€ ì…ë ¥ë˜ì—ˆëŠëƒì— ë”°ë¼ ë‹¤ë¥¸ ìŠ¤í‚¬ì„ ì‹¤í–‰í•¨
		const FString Skill_Number = TEXT("Skill") + FString::FromInt(ExecutedSkillNum);
	
		if (SkillRowHandleNum >= ExecutedSkillNum)
		{
		    FSkillTableRow* SkillRow = WeaponTableRow->SkillRowHandle[ExecutedSkillNum - 1].GetRow<FSkillTableRow>(Skill_Number);
	
		    if (!SkillRow) { ensure(false); return; }
	
		    UAnimMontage* CurrentMontage = BasicAnimInstance->GetCurrentActiveMontage();
	
		    // í˜„ì¬ ëª½íƒ€ì£¼ê°€ ì¬ìƒ ì¤‘ì´ì§€ ì•Šì„ ë•Œ
		    if (nullptr == CurrentMontage)
		    {
			if (ABasicPlayer* WeaponOwner = Cast<ABasicPlayer>(OwningCharacter))
			{
			    UStatusComponent* StatusComponent = WeaponOwner->GetComponentByClass<UStatusComponent>();
			    if (StatusComponent->IsPlayer())
			    {
				UAnimMontage* PlayingMontage = WeaponOwner->GetPlayingMontage();
				if (PlayingMontage)
				{
				    WeaponOwner->SetPlayingMontage(nullptr);
				}
	
				// ìŠ¤í‚¬ ë°ì´í„° í…Œì´ë¸”ì— ìˆëŠ” ëª½íƒ€ì£¼ë¥¼ ì¬ìƒ
				WeaponOwner->SetPlayingMontage(SkillRow->SkillMotionMontage);
			    }
			    else
			    {
				if (ADefaultMonster* WeaponOwnerIsMonster = Cast<ADefaultMonster>(OwningCharacter))
				{
				    UAnimMontage* PlayingMontage = WeaponOwnerIsMonster->GetPlayingMontage();
				    if (PlayingMontage)
				    {
					WeaponOwnerIsMonster->SetPlayingMontage(nullptr);
				    }
				    WeaponOwnerIsMonster->SetPlayingMontage(SkillRow->SkillMotionMontage);
				}
			    }
			}
			BasicAnimInstance->Montage_Play(SkillRow->SkillMotionMontage);
		    }
		}
	    }
	}
       ```
      </details><br>


  - Projectileì´ **Ground Projectile**ë¡œ ì„¤ì •ëœ Skill ì‚¬ìš© ì‹œ
<br></br>
**Ground Projectile**ì€ Player ì•ì— ë•…ì´ ìˆì–´ì•¼ ìƒì„±ë˜ëŠ” ë°œì‚¬ì²´.<br>
Playerë¥¼ ì¤‘ì‹¬( ìºë¦­í„°ì˜ ë°°ê¼½ ìœ„ì¹˜ )ì„ ê¸°ì¤€ìœ¼ë¡œ ì „ë°©ì— ë°”ë‹¥ì´ ì¡´ì¬í•œë‹¤ë©´<br>
Ground Projectileì´ ìƒì„±ë˜ê³ , ë°”ë‹¥ì´ ì—†ë‹¤ë©´ ìƒì„±ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
<br></br>
![groundproject](https://github.com/user-attachments/assets/36e000cf-694d-49c4-94af-ed1080a55919)

      <details>
        <summary> AGroundProjectile í´ë˜ìŠ¤ì˜ BeginPlay í•¨ìˆ˜ ì½”ë“œ ( GroundProjectileì˜ ìƒì„± ìœ„ì¹˜ë¥¼ ì¡°ì • )</summary>
    
     

    
       ```cpp
       /* Skill ë°ì´í„° í…Œì´ë¸”ì—ì„œ Projectile ì„¤ì •ì´ GroundProjectileë¡œ ì„¤ì •ëœ Skillì„ ì‚¬ìš©í•˜ë©´ GroundProjectile ê°ì²´ê°€ ìƒì„±ë©ë‹ˆë‹¤.
        * GroundProjectileì€ Playerì˜ ì¤‘ì‹¬ì„ ê¸°ì¤€ìœ¼ë¡œ, Skill ë°ì´í„° í…Œì´ë¸”ì—ì„œ ì„¤ì •í•œ Transformê°’ì„ í¬í•¨í•œ ìœ„ì¹˜ì— ìƒì„±ë©ë‹ˆë‹¤.
        * GroundProjectileì´ ìƒì„±ë˜ë©´ GroundProjectile ìœ„ì¹˜ ê¸°ì¤€, ì•„ë˜ ë°©í–¥ìœ¼ë¡œ LineTraceë¥¼ ë°œì‚¬í•˜ì—¬ ì˜¤ë¸Œì íŠ¸ë¥¼ ê°ì§€í•©ë‹ˆë‹¤.
        * Collisionì´ Floorë¡œ ì„¤ì •ëœ ì˜¤ë¸Œì íŠ¸ê°€ ê°ì§€ë˜ì—ˆë‹¤ë©´ ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸ ìœ„ë¡œ GroundProjectileì„ ì˜®ê¹ë‹ˆë‹¤.
        * ë§Œì•½ Collisionì´ Floorë¡œ ì„¤ì •ëœ ì˜¤ë¸Œì íŠ¸ê°€ ì•„ë‹Œ, ë‹¤ë¥¸ ì˜¤ë¸Œì íŠ¸ê°€ ê°ì§€ë˜ê±°ë‚˜ ì•„ë¬´ê²ƒë„ ê°ì§€ë˜ì§€ ì•Šìœ¼ë©´
        * ìœ„ìª½ ë°©í–¥ìœ¼ë¡œ LineTraceë¥¼ ë°œì‚¬í•˜ì—¬ ì˜¤ë¸Œì íŠ¸ë¥¼ ê°ì§€í•©ë‹ˆë‹¤.
        * ë§ˆì°¬ê°€ì§€ë¡œ Collisionì´ Floorë¡œ ì„¤ì •ëœ ì˜¤ë¸Œì íŠ¸ê°€ ê°ì§€ë˜ì—ˆë‹¤ë©´ ê°ì§€ëœ ì˜¤ë¸Œì íŠ¸ ìœ„ë¡œ GroundProjectileì„ ì˜®ê¹ë‹ˆë‹¤.
        * ì´ ê²½ìš°ì—ë„ ì•„ë¬´ê²ƒë„ ê°ì§€ë˜ì§€ ì•Šìœ¼ë©´ GroundProjectileì„ Destroyí•©ë‹ˆë‹¤.                     
        */
	void AGroundProjectile::BeginPlay()
	{
		Super::BeginPlay();
	
		// GroundProjectileì˜ ìœ„ì¹˜ ì–»ì–´ì˜¤ê¸°
		FVector GroundProjectileLocation = GetActorLocation();
		// ì•„ë˜ ë°©í–¥ìœ¼ë¡œ LineTraceë¥¼ ë°œì‚¬
		FHitResult DownHitResult;
		{
			TArray<AActor*> IgnoreActors; IgnoreActors.Add(GetOwner());
	
			// í•´ë‹¹ TraceëŠ” FloorDetectTraceChannelë¡œ ë°œì‚¬ë˜ëŠ” Traceì´ë‹¤. 
			// ë°œì‚¬ëœ í•´ë‹¹ TraceëŠ” Collisionì´ Floorë¡œ ì„¤ì •ëœ ì˜¤ë¸Œì íŠ¸ë¥¼ ê°ì§€í•œë‹¤.
			// Floorë¡œ ì„¤ì •ëœ ì˜¤ë¸Œì íŠ¸ì—ë§Œ GroundProjectile ìŠ¤í‚¬ì„ ìŠ¤í°ì‹œí‚¤ëŠ” ê²ƒì´ ëª©ì .
			const ETraceTypeQuery TraceTypeQuery = UEngineTypes::ConvertToTraceType(ECollisionChannel::ECC_GameTraceChannel5);
			const bool bHit = UKismetSystemLibrary::LineTraceSingle(GetWorld(),
				GetActorLocation(), GetActorLocation() + FVector(0, 0, -350), TraceTypeQuery,
				false, IgnoreActors, EDrawDebugTrace::ForDuration, DownHitResult, true);
			// ë§Œì•½ Hitê°€ ë°œìƒí–ˆë‹¤ë©´ ê·¸ ìœ„ì¹˜ë¡œ GroundProjectileì„ ì˜®ê¹€
			if (bHit)
			{
				GroundProjectileLocation.Z = DownHitResult.ImpactPoint.Z;
				SetActorLocation(GroundProjectileLocation);
	
				return;
			}
		}
		// ìœ„ìª½ ë°©í–¥ìœ¼ë¡œ LineTraceë¥¼ ë°œì‚¬
		FHitResult UpHitResult;
		{
			TArray<AActor*> IgnoreActors; IgnoreActors.Add(GetOwner());
	
			const ETraceTypeQuery TraceTypeQuery = UEngineTypes::ConvertToTraceType(ECollisionChannel::ECC_GameTraceChannel5);
			const bool bHit = UKismetSystemLibrary::LineTraceSingle(GetWorld(),
				GetActorLocation(), GetActorLocation() + FVector(0, 0, 200), TraceTypeQuery,
				false, IgnoreActors, EDrawDebugTrace::ForDuration, UpHitResult, true);
	
			if (bHit)
			{
				GroundProjectileLocation.Z = UpHitResult.ImpactPoint.Z;
				SetActorLocation(GroundProjectileLocation);
				
				return;
			}
		}
		
		// Floorê°€ ê°ì§€ë˜ì§€ ì•Šìœ¼ë©´ GroundProjectileì„ ê·¸ëƒ¥ ì œê±°í•œë‹¤.
		Destroy();
	}
 	```
      </details>

 
      <details>
        <summary> AGroundProjectile í´ë˜ìŠ¤ì˜ OnBeginOverlap í•¨ìˆ˜ ì½”ë“œ ( GroundProjectileì´ ë‹¤ë¥¸ ì˜¤ë¸Œì íŠ¸ì™€ ì ‘ì´‰í•  ì‹œ í˜¸ì¶œ )</summary>
    
     

    
       ```cpp
       /* GroundProjectileê³¼ Collisionì´ Floorë¡œ ì„¤ì •ëœ ì˜¤ë¸Œì íŠ¸ê°€ ì ‘ì´‰í•˜ë©´ Decal Effectë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
        * ì ‘ì´‰í–ˆë‹¤ë©´ DetectDamageTarget í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
        * DetectDamageTarget í•¨ìˆ˜ëŠ” BoxTraceë¥¼ ë°œì‚¬í•˜ì—¬ ë°ë¯¸ì§€ë¥¼ ì ìš©í•  ìˆ˜ ìˆëŠ” ì˜¤ë¸Œì íŠ¸ê°€ ìˆëŠ”ì§€ ì²´í¬í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
        * ì´í›„ GroundProjectileì„ íŒŒê´´í•©ë‹ˆë‹¤.
        * ë°ë¯¸ì§€ë¥¼ ì ìš©í•  ìˆ˜ ìˆëŠ” ì˜¤ë¸Œì íŠ¸ê°€ ì¡´ì¬í•œë‹¤ë©´, UGameplayStaticsì˜ ApplyDamage í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ë°ë¯¸ì§€ë¥¼ ì ìš©í•©ë‹ˆë‹¤.
        */
	void AGroundProjectile::OnBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
	{
		if (!IsValid(this)) { return; }
		
		FTransform NewTransform = GetActorTransform();
		
		// DecalEffect ì¶œë ¥
		{
			FProjectileTableRow* EffectTableRow = DataTableRowHandle.GetRow<FProjectileTableRow>(TEXT("Effect"));
			FEffectDecalTableRow* DecalEffectTableRow = EffectTableRow->EffectTableRowHandle.GetRow<FEffectDecalTableRow>(TEXT("DecalEffect"));
	
			AEffectWithDecal* DecalEffect = GetWorld()->SpawnActorDeferred<AEffectWithDecal>(DecalEffectTableRow->EffectWithDecalClass,
				FTransform::Identity);
	
			FDataTableRowHandle DecalTableRowHandle = EffectTableRow->EffectTableRowHandle;
	
			DecalEffect->SetData(DecalTableRowHandle);
			NewTransform.SetScale3D(DecalEffectTableRow->OverlapParticleTransform.GetScale3D());
			DecalEffect->FinishSpawning(NewTransform);
			// DecalEffectì˜ ìœ„ì¹˜ë¥¼ FinishSpawning í•¨ìˆ˜ë¥¼ í†µí•´ ì¡°ì •í•˜ëŠ” ê²ƒì¼ ë¿,
			// Play í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë©´ ì›ì ì— ë¬´ì¡°ê±´ DecalEffectê°€ ì¶œë ¥ëœë‹¤.
			DecalEffect->Play();
		}
	
		ABasicPlayer* OwningCharacter = Cast<ABasicPlayer>(GetOwner());
		check(OwningCharacter);
	
		// Skill Data Table ì–»ì–´ì˜¤ê¸°
	  	// ìŠ¤í‚¬ì„ ê´€ë¦¬í•˜ëŠ” ë°°ì—´ì— ì ‘ê·¼í•˜ì—¬ ìŠ¤í‚¬ ì‹œì „ ì• ë‹ˆë©”ì´ì…˜ê³¼
	  	// í”Œë ˆì´ì–´ê°€ ì¬ìƒ ì¤‘ì¸ ìŠ¤í‚¬ ì‹œì „ ì• ë‹ˆë©”ì´ì…˜ê³¼ ê°™ì€ ê²ƒì„ ì°¾ì•„ëƒ„.
		// Notifyë¥¼ ë°œìƒì‹œí‚¨ ì• ë‹ˆë©”ì´ì…˜ê³¼ ì¼ì¹˜í•˜ëŠ” ì• ë‹ˆë©”ì´ì…˜ì´ ìˆëŠ” ìŠ¤í‚¬ ë°°ì—´ì˜ ì¸ë±ìŠ¤ë¥¼ ì €ì¥í•˜ê³  ê·¸ ìŠ¤í‚¬ ë°°ì—´ì— ìˆëŠ” ë°ì´í„° í…Œì´ë¸”ì— ì ‘ê·¼í•˜ì—¬ ë°˜í™˜
		const FSkillTableRow* SkillTableRow = OwningCharacter->GetSkillTableRow();
		ensure(SkillTableRow);
	
		// GroundProjectileì´ Floorì™€ Overlapë˜ë©´ 
		// BoxTraceë¥¼ ì´ìš©í•´ ë°ë¯¸ì§€ë¥¼ ì¤„ íƒ€ê²Ÿì„ ê°ì§€í•œë‹¤.
		AActor* DetectActor = DetectDamageTarget();
	
		Destroy();
	
		// íƒ€ê²Ÿì´ ê°ì§€ë˜ì—ˆë‹¤ë©´ ë°ë¯¸ì§€ ì£¼ê¸°
		if(DetectActor)
		{
			UGameplayStatics::ApplyDamage(DetectActor, SkillTableRow->SkillDamage, GetInstigator()->GetController(), this, nullptr);
		}
	}
	```
	</details><br>
      
  - Projectileì´ **Straight Projectile**ë¡œ ì„¤ì •ëœ Skill ì‚¬ìš© ì‹œ
<br></br>
**Straight Projectile**ì€ Playerë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ì¼ì§ì„ ìœ¼ë¡œ ë°œì‚¬ë˜ëŠ” Projectile.<br>
Straight Projectileì´ ë‚ ì•„ê°€ëŠ” ë™ì•ˆ Projectile ì£¼ë³€ì— ëª¬ìŠ¤í„°ê°€ ìˆëŠ”ì§€ ê°ì§€.<br>
ëª¬ìŠ¤í„°ê°€ ê°ì§€ë˜ì—ˆë‹¤ë©´ í•´ë‹¹ ëª¬ìŠ¤í„°ìª½ìœ¼ë¡œ ë‚ ì•„ê°‘ë‹ˆë‹¤.
<br></br>
![stra](https://github.com/user-attachments/assets/fa9d8cb8-2b37-4320-853e-5277b883c955)

      <details>
        <summary> AStraightProjectile í´ë˜ìŠ¤ì˜ BeginPlay í•¨ìˆ˜ì™€ DetectDamageTarget í•¨ìˆ˜ ì½”ë“œ ( Straight Projectile ìƒì„± ì‹œ, ë²”ìœ„ ë‚´ ëª¬ìŠ¤í„°ë¥¼ ê°ì§€ ) </summary>
    
     

    
       ```cpp
       /* Straight Projectileì´ ìƒì„±ë˜ë©´ AStraightProjectile í´ë˜ìŠ¤ì˜ BeginPlay í•¨ìˆ˜ê°€ í˜¸ì¶œë©ë‹ˆë‹¤.
        * BeginPlay í•¨ìˆ˜ëŠ” DetectDamageTarget í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ë°˜í™˜ê°’ì„ DetectActorì— ì €ì¥í•©ë‹ˆë‹¤.
        * DetectDamageTarget í•¨ìˆ˜ëŠ” ê°ì§€ëœ ëª¬ìŠ¤í„°ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
        * Straight Projectileì˜ ì´ë™ ê²½ë¡œ ê·¼ì²˜ì— Collisionì´ ëª¬ìŠ¤í„°ë¡œ ì„¤ì •ëœ ì˜¤ë¸Œì íŠ¸ê°€ ìˆëŠ”ì§€ Box Traceë¥¼ í†µí•´ ê°ì§€í•©ë‹ˆë‹¤.
        * ê°ì§€ë˜ì—ˆë‹¤ë©´ í•´ë‹¹ ì˜¤ë¸Œì íŠ¸ë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ë¥¼ ë°˜í™˜í•˜ê³  DetectDamageTarget í•¨ìˆ˜ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.
        */
	void AStraightProjectile::BeginPlay()
	{
		Super::BeginPlay();
	
		DetectActor = DetectDamageTarget();
	}
	
	AActor* AStraightProjectile::DetectDamageTarget()
	{
		FHitResult DetectResult;
		{
		TArray<AActor*> IgnoreActors; IgnoreActors.Add(GetOwner());
	
			FVector TraceStartLocation = GetActorLocation();  // Trace ì‹œì‘ ìœ„ì¹˜
			FVector TraceDirection = GetActorForwardVector();  // ì˜ˆ: ì „ë°© ë²¡í„° (ì •í™•í•œ ë°©í–¥ì€ ìƒí™©ì— ë”°ë¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ)
	
			// ìƒˆë¡œìš´ ìœ„ì¹˜ ê³„ì‚°
			FVector TraceEndLocation = TraceStartLocation + (TraceDirection * Distance);
	
			// StraightProjectileì˜ í¬ê¸°ë¥¼ ì–»ì–´ì™€ì„œ 
			FVector Origin;
			FVector BoxExtent;
			GetActorBounds(false, Origin, BoxExtent);
			
			// Projectileì˜ ìì‹ìœ¼ë¡œ ë¶™ì–´ìˆëŠ” íŒŒí‹°í´ ì‹œìŠ¤í…œì˜ í¬ê¸°ëŠ” ë¹¼ì¤€ë‹¤.
			if (ProjectileMeshEffectComponent)
			{
				// íŒŒí‹°í´ ì‹œìŠ¤í…œì˜ í¬ê¸° ê³„ì‚°
				FBox ParticleBounds = ProjectileMeshEffectComponent->Bounds.GetBox();
				FVector ParticleExtent = ParticleBounds.GetExtent();
	
				// íŒŒí‹°í´ ì‹œìŠ¤í…œ í¬ê¸°ë¥¼ ë°˜ì˜í•˜ì§€ ì•Šìœ¼ë ¤ë©´ BoxExtentì—ì„œ ë¹¼ê¸°
				BoxExtent -= ParticleExtent;
			}
	
			// ê°ì§€ ë²”ìœ„ ì¡°ì ˆ
			BoxExtent.Y += 50;
			BoxExtent.Z += 150;
			FVector DetectRange = BoxExtent;
	
		     //í•´ë‹¹ TraceëŠ” MonsterDetectTraceChannelë¡œ ë°œì‚¬ë˜ëŠ” Traceì´ë‹¤. 
			// ë°œì‚¬ëœ í•´ë‹¹ TraceëŠ” Collisionì´ Monsterë¡œ ì„¤ì •ëœ ì˜¤ë¸Œì íŠ¸ë¥¼ ê°ì§€í•œë‹¤.
			const ETraceTypeQuery TraceTypeQuery = UEngineTypes::ConvertToTraceType(ECollisionChannel::ECC_GameTraceChannel8);
			const bool bHit = UKismetSystemLibrary::BoxTraceSingle(GetWorld(),
				TraceStartLocation, TraceEndLocation, DetectRange, GetOwner()->GetActorRotation(), TraceTypeQuery,
				false, IgnoreActors, EDrawDebugTrace::ForDuration, DetectResult, true);	
	
			if (bHit)
			{
				AActor* TraceDetectActor = DetectResult.GetActor();
	
				if (TraceDetectActor)
				{
					return TraceDetectActor;
				}
			}
		}
		return nullptr;
	}
	```
	</details>

 
      <details>
        <summary> AStraightProjectile í´ë˜ìŠ¤ì˜ Tick í•¨ìˆ˜ì™€ FollowDamageTarget í•¨ìˆ˜ ì½”ë“œ ( Straight Projectileì´, ê°ì§€í•œ ëª¬ìŠ¤í„° ìª½ìœ¼ë¡œ ì´ë™ ) </summary>
    
     

    
       ```cpp
       /* Straight Projectileì´ ì¡´ì¬í•˜ëŠ” ë™ì•ˆ AStraightProjectile í´ë˜ìŠ¤ì˜ Tick í•¨ìˆ˜ê°€ í˜¸ì¶œë©ë‹ˆë‹¤.
        * Tick í•¨ìˆ˜ì—ì„œëŠ” ë©¤ë²„ í¬ì¸í„°ì¸ DetectActorê°€ ê°€ë¦¬í‚¤ëŠ” ì˜¤ë¸Œì íŠ¸ê°€ ì¡´ì¬í•œë‹¤ë©´, FollowDamageTarget í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
        * FollowDamageTarget í•¨ìˆ˜ëŠ” ì¸ìë¡œ ë°›ì€ ì˜¤ë¸Œì íŠ¸(ëª¬ìŠ¤í„°)ë¥¼ Straight Projectileì´ ë”°ë¼ê°ˆ ìˆ˜ ìˆë„ë¡ í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
        * FollowDamageTarget í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ ë”°ë¼ê°€ì•¼ í•˜ëŠ” ì˜¤ë¸Œì íŠ¸ê°€ ì–´ë–¤ ë°©í–¥ì— ì¡´ì¬í•˜ëŠ”ì§€ ê³„ì† ì²´í¬í•©ë‹ˆë‹¤.
        * ê·¸ë¦¬ê³  Straight Projectileì„ í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ íšŒì „ì‹œí‚µë‹ˆë‹¤.
        * Straight Projectileì€ ìƒì„± ì‹œ ì¼ì •í•œ ë°©í–¥ìœ¼ë¡œ ì´ë™í•˜ê³  ì†ë„(Velocity)ë„ ì´ë¯¸ ì„¤ì •ë˜ì–´ ìˆìœ¼ë¯€ë¡œ, 
        * FollowDamageTarget í•¨ìˆ˜ì—ì„œ ë°©í–¥ë§Œ ì„¤ì •í•´ì£¼ì–´ë„ ë°œì‚¬ì²´ê°€ íƒ€ê²Ÿìœ¼ë¡œ ì´ë™í•˜ê²Œ ë©ë‹ˆë‹¤.
        */
	void AStraightProjectile::Tick(float DeltaTime)
	{
		Super::Tick(DeltaTime);
	
		if (DetectActor)
		{
			FollowDamageTarget(DetectActor);
		}
	}
	
	void AStraightProjectile::FollowDamageTarget(AActor* TargetActor)
	{
		// ê°ì§€ëœ Actorë¥¼ ë”°ë¼ê°€ëŠ” í•¨ìˆ˜
		// íƒ€ê²Ÿ ë°©í–¥ì„ ê³„ì‚°.
		FVector DirectionToTarget = (TargetActor->GetActorLocation() - GetActorLocation()).GetSafeNormal();
	
		// ë°œì‚¬ì²´ë¥¼ íƒ€ê²Ÿ ë°©í–¥ìœ¼ë¡œ íšŒì „ì‹œí‚´.
		FRotator NewRotation = DirectionToTarget.Rotation();
		SetActorRotation(NewRotation);
	
		ProjectileMovementComponent->Velocity = DirectionToTarget * ProjectileData->InitialSpeed;
	}
	```
	</details><br>

      
  - Player í”¼ê²© ì‹œ, Overlay Materialì˜ Opacity ê°’ì„ ì¡°ì •í•˜ì—¬ ê¹œë¹¡ì´ëŠ” íš¨ê³¼ ë¶€ì—¬ 
<br></br>
![blinkCha](https://github.com/user-attachments/assets/394c9701-0187-46b3-941f-3b93eed8dc8f)

      <details>
        <summary> UCharacterMeshEffect í´ë˜ìŠ¤ì˜ ApplyHitMaterial í•¨ìˆ˜ ì½”ë“œ ( UCharacterMeshEffectëŠ” Playerì˜ ë©”ì‹œì— íš¨ê³¼ë¥¼ ì£¼ê¸° ìœ„í•œ í´ë˜ìŠ¤ ) </summary>
    
     

    
       ```cpp
       /* Playerì˜ ë©”ì‹œëŠ” ì˜¤ë²„ë ˆì´ ë¨¸í‹°ë¦¬ì–¼ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.
        * Playerê°€ í”¼ê²©ë  ê²½ìš° ì˜¤ë²„ë ˆì´ ë¨¸í‹°ë¦¬ì–¼ì˜ HitOverlayOpacityë¼ëŠ” Parameterì˜ ê°’ì„ ë³€ê²½í•©ë‹ˆë‹¤.
        * ê¸°ë³¸ì ìœ¼ë¡œ HitOverlayOpacityì˜ ê°’ì€ 0ì´ë©°, í”¼ê²©ë  ê²½ìš° 0.6ìœ¼ë¡œ ê°’ì´ ì„¤ì •ë˜ì–´ Playerì˜ ë©”ì‹œê°€ ë³´ë¼ìƒ‰ì´ ë©ë‹ˆë‹¤.
        * ì´í›„ HitOverlayOpacityì˜ ê°’ì„ ë‹¤ì‹œ 0ìœ¼ë¡œ, ê·¸ë¦¬ê³  0.6ìœ¼ë¡œ ì„¤ì •í•˜ëŠ” ê²ƒì„ ë°˜ë³µí•˜ì—¬ ë³´ë¼ìƒ‰ìœ¼ë¡œ ê¹œë¹¡ì´ëŠ” íš¨ê³¼ë¥¼ ì¤ë‹ˆë‹¤.
        * Playerê°€ ì‚¬ë§í•˜ê±°ë‚˜, ì¼ì • ì‹œê°„ì´ ì§€ë‚˜ë©´ HitOverlayOpacityì˜ ê°’ì„ 0ìœ¼ë¡œ ì„¤ì •í•¨ìœ¼ë¡œì¨ ê¹œë¹¡ì„ì„ ë©ˆì¶¥ë‹ˆë‹¤.
        */
	void UCharacterMeshEffect::ApplyHitMaterial(const float Duration)
	{
	    if (!OwningPlayer || !TargetMeshComponent)
	    {
	        UE_LOG(LogTemp, Warning, TEXT("OwningPlayer or MeshComponent is nullptr."));
	        return;
	    }
	
	    // 1. Overlay Materialì„ ê°€ì ¸ì˜¤ê¸°
	    OriginalOverlayMaterial = TargetMeshComponent->GetOverlayMaterial();
	
	    if (!OriginalOverlayMaterial)
	    {
	        UE_LOG(LogTemp, Warning, TEXT("OriginalOverlayMaterial is nullptr, í”Œë ˆì´ì–´ Meshì—ëŠ” ì˜¤ë²„ë ˆì´ ë¨¸í‹°ë¦¬ì–¼ì´ ì¡´ì¬í•´ì•¼ í•©ë‹ˆë‹¤."));
	        return;
	    }
	    
	    // 2. Overlay Materialì„ ë™ì  ë¨¸í‹°ë¦¬ì–¼ ì¸ìŠ¤í„´ìŠ¤ë¡œ ë³€í™˜
	    UMaterialInstanceDynamic* DynOverlayMaterial = UMaterialInstanceDynamic::Create(OriginalOverlayMaterial, this);
	
	    if (DynOverlayMaterial)
	    {
	        DynOverlayMaterial->SetScalarParameterValue("HitOverlayOpacity", 0.6f);
	        TargetMeshComponent->SetOverlayMaterial(DynOverlayMaterial);
	
	        // BlinkTimerHandleê°€ ì‘ë™í•˜ê³  ìˆì§€ ì•Šì„ ë•Œì—ë§Œ ì•„ë˜ ì½”ë“œ ì‹¤í–‰
	        if (!GetWorld()->GetTimerManager().IsTimerActive(BlinkTimerHandle))
	        {
	            // (Duration / x.f)ì´ˆë§ˆë‹¤ BlinkMaterial í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•¨
	            GetWorld()->GetTimerManager().SetTimer(BlinkTimerHandle, [this, DynOverlayMaterial]()
	                {
	                    BlinkMaterial(DynOverlayMaterial);
	                }, Duration / 30.f, true);
	        }
	
	        // RestoreTimerHandleê°€ ì‘ë™í•˜ê³  ìˆì§€ ì•Šì„ ë•Œì—ë§Œ ì•„ë˜ ì½”ë“œ ì‹¤í–‰
	        if (!GetWorld()->GetTimerManager().IsTimerActive(RestoreTimerHandle))
	        {
	            // OwningPlayerê°€ ì‚¬ë§ ìƒíƒœë¼ë©´ ëœ ê¹œë¹¡ì„
	            if (OwningPlayer && OwningPlayer->GetStatusComponent()->IsDie())
	            {
	                // Duration / xì´ˆ í›„ì— íƒ€ì´ë¨¸ë¥¼ ë©ˆì¶”ë„ë¡ ì„¤ì •
	                GetWorld()->GetTimerManager().SetTimer(RestoreTimerHandle, [this, DynOverlayMaterial]()
	                    {
	                        RestoreOriginalMaterial(DynOverlayMaterial);
	
	                        // íƒ€ì´ë¨¸ ì •ì§€
	                        GetWorld()->GetTimerManager().ClearTimer(BlinkTimerHandle);
	                        GetWorld()->GetTimerManager().ClearTimer(RestoreTimerHandle);
	
	                        InitializeMembers();
	
	                    }, Duration / 3.f , false);
	            }
	            else
	            {
	                // Durationì´ˆ í›„ì— íƒ€ì´ë¨¸ë¥¼ ë©ˆì¶”ë„ë¡ ì„¤ì •
	                GetWorld()->GetTimerManager().SetTimer(RestoreTimerHandle, [this, DynOverlayMaterial]()
	                    {
	                        RestoreOriginalMaterial(DynOverlayMaterial);
	
	                        // íƒ€ì´ë¨¸ ì •ì§€
	                        GetWorld()->GetTimerManager().ClearTimer(BlinkTimerHandle);
	                        GetWorld()->GetTimerManager().ClearTimer(RestoreTimerHandle);
	
	                        InitializeMembers();
	
	                    }, Duration, false);
	            }
	        }
	    }
	}
	
	void UCharacterMeshEffect::BlinkMaterial(UMaterialInstanceDynamic* OutDynOverlayMaterial)
	{
	    if (BlinkCount % 2 == 0)
	    {
	        // HitOverlayOpacityê°’ì„ 0.0fë¡œ ì„¤ì •, ê¸°ë³¸ ìƒíƒœë‘ ê°™ìŒ
	        OutDynOverlayMaterial->SetScalarParameterValue("HitOverlayOpacity", 0.0f);
	    }
	    else
	    {
	        // HitOverlayOpacityê°’ì„ 0.6fë¡œ ì„¤ì •, OverlayMaterialì´ ìºë¦­í„°ì—ê²Œ ë°˜íˆ¬ëª… í˜•íƒœë¡œ ë‚˜íƒ€ë‚¨
	        OutDynOverlayMaterial->SetScalarParameterValue("HitOverlayOpacity", 0.6f);
	    }
	
	    // íŒŒë¼ë¯¸í„° ë³€ê²½ í›„ Overlay Material ì¬ì„¤ì •
	    TargetMeshComponent->SetOverlayMaterial(OutDynOverlayMaterial);
	
	    // BlinkCount ì¦ê°€
	    ++BlinkCount;
	}
	
	void UCharacterMeshEffect::RestoreOriginalMaterial(UMaterialInstanceDynamic* OutDynOverlayMaterial)
	{
	    TargetMeshComponent->SetOverlayMaterial(OriginalOverlayMaterial);
	}
	
	void UCharacterMeshEffect::InitializeMembers()
	{
	
	    OriginalOverlayMaterial = nullptr;
	
	    BlinkCount = 0;
	    BlinkTimerHandle.Invalidate();
	    RestoreTimerHandle.Invalidate(); 
	}
	```
	</details><br>
                    



### 2. Monster
  - Monster ì‚¬ë§ ì‹œ, Materialì„ êµì²´í•˜ê³  Opacity ê°’ì„ ìˆ˜ì •
                                <br><br>
![monsteropa](https://github.com/user-attachments/assets/3a84ac96-a652-4355-9202-95e3382456a1)

      <details>
        <summary> ADefaultMonster í´ë˜ìŠ¤ì˜ BeginPlayì™€ OnDisappearMesh, OnDisappearMeshEnd í•¨ìˆ˜ ì½”ë“œ </summary>
    
     

    
       ```cpp
       /* í˜„ì¬ Monsterì˜ ë©”ì‹œëŠ” Opacityë¥¼ ìˆ˜ì •í•  ìˆ˜ ì—†ëŠ” ë©”ì‹œë¡œ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
        * ADefaultMonster í´ë˜ìŠ¤ì˜ BeginPlay í•¨ìˆ˜ì—ì„œ
        * ë©¤ë²„ ë³€ìˆ˜ MaterialInstanceDynamicsì— Opacityë¥¼ ìˆ˜ì •í•  ìˆ˜ ìˆëŠ” Materialì„ ì €ì¥í•©ë‹ˆë‹¤.
        * Monster ì‚¬ë§ ì‹œ, OnDisappearMesh í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬
        * Monsterì˜ ë©”ì‹œë¥¼ MaterialInstanceDynamicsì— ì €ì¥ëœ Materialë¡œ êµì²´í•˜ê³  
        * Opacityë¥¼ ì¡°ì •í•©ë‹ˆë‹¤. ì´ë¡œì¨ Monsterì˜ ë©”ì‹œê°€ ì ì  íˆ¬ëª…í•´ì§€ë„ë¡ ì—°ì¶œí•  ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤.
        * OnDisappearMesh í•¨ìˆ˜ê°€ ì¢…ë£Œë˜ë©´ OnDisappearMeshEnd í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ Monsterë¥¼ Destroyí•©ë‹ˆë‹¤.
        */
	void ADefaultMonster::BeginPlay()
	{
		Super::BeginPlay();
		
		SetData(DataTableRowHandle);
	
		USkeletalMeshComponent* SkeletalMeshComponent = GetComponentByClass<USkeletalMeshComponent>();
	
		// 1ë²ˆ ì¸ë±ìŠ¤ì— ìˆëŠ” Materialì´ BlendModeê°€ Translucentë¡œ ì„¤ì •ë˜ì–´, Opacityë¥¼ ìˆ˜ì •í•  ìˆ˜ ìˆëŠ” Materialì´ë‹¤.
		// MaterialInstanceDynamicsëŠ” 1ë²ˆ ì¸ë±ìŠ¤ì— ìˆëŠ” Materialì„ ê°€ë¦¬í‚¤ëŠ” ë©¤ë²„ ë³€ìˆ˜
		MaterialInstanceDynamics = SkeletalMeshComponent->CreateAndSetMaterialInstanceDynamic(1);
		ensureMsgf(MaterialInstanceDynamics->GetBlendMode() == EBlendMode::BLEND_Translucent && MaterialInstanceDynamics, TEXT("1ë²ˆ ì¸ë±ìŠ¤ì— ì¡´ì¬í•˜ëŠ” Materialì´ ì—†ê±°ë‚˜, BlendModeê°€ Translucentê°€ ì•„ë‹™ë‹ˆë‹¤."));
	
		if (DisappearCurve)	// DisappearCurve ê°’ ì„¸íŒ…
		{
			// ëª¬ìŠ¤í„° ì‚¬ë§ ëª¨ì…˜ì€ í•˜ë‚˜ë¡œ í•¨
			float DieMontagePlayLength = MonsterData->DieMontage->GetPlayLength();
			
			// í‚¤í”„ë ˆì„ ì¶”ê°€
			FKeyHandle KeyHandle1 = DisappearCurve->FloatCurve.AddKey(0.0f, 1.0f);  // ì‹œê°„ 0ì—ì„œ ê°’ 1
			// ê°’ì´ ì ì  ì¦ê°€í•˜ëŠ” Curve
			FKeyHandle KeyHandle3 = DisappearCurve->FloatCurve.AddKey(DieMontagePlayLength, DieMontagePlayLength);  // ì‹œê°„ DieMontagePlayLengthì—ì„œ ê°’ DieMontagePlayLength
	
			DisappearCurve->FloatCurve.SetKeyInterpMode(KeyHandle1, RCIM_Cubic);  // ì„ í˜• ë³´ê°„
			DisappearCurve->FloatCurve.SetKeyInterpMode(KeyHandle3, RCIM_Cubic);
		}
		FOnTimelineFloat Delegate;
		Delegate.BindDynamic(this, &ThisClass::OnDisappearMesh);
		// Delegateì™€ ì—°ë™ëœ, ì¦‰ OnDisappearMesh í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œ DisappearCurveë¥¼ ì¸ìë¡œ ë„˜ê¸´ë‹¤.
		DisappearTimelineComponent->AddInterpFloat(DisappearCurve, Delegate);
	
		FOnTimelineEvent EndDelegate;
		EndDelegate.BindDynamic(this, &ThisClass::OnDisappearMeshEnd);
		DisappearTimelineComponent->SetTimelineFinishedFunc(EndDelegate);
	
		...
	}

	void ADefaultMonster::OnDisappearMesh(float InDissolve)
	{
		if (MaterialInstanceDynamics)
		{
			USkeletalMeshComponent* SkeletalMeshComponent = GetComponentByClass<USkeletalMeshComponent>();
			// MaterialInstanceDynamicsê°€ ê°€ë¦¬í‚¤ê³  ìˆëŠ”, BlendModeê°€ Translucentë¡œ ì„¤ì •ëœ
			// Materialì„ Monsterì˜ 0ë²ˆ Materialë¡œ ì„¤ì •í•´ ì¤€ë‹¤.
			SkeletalMeshComponent->SetMaterial(0, MaterialInstanceDynamics);
	
			// CurrentTransparencyì˜ ì´ˆê¹ƒê°’ì€ 1ì´ë‹¤.
			float CurrentTransparency;
			MaterialInstanceDynamics->GetScalarParameterValue(FName("Opacity"), CurrentTransparency);
	
			float SpeedMultiplier = 0.005f; // ë‚®ì„ìˆ˜ë¡ íˆ¬ëª…ë„ ê°ì†Œ ì†ë„ë¥¼ ë” ì²œì²œíˆ ë§Œë“­ë‹ˆë‹¤.
			
			// CurrentTransparencyì˜ ê°’ì„ ì ì  ê°ì†Œì‹œì¼œ ëª¬ìŠ¤í„°ê°€ ì ì  íˆ¬ëª…í•´ì§€ë„ë¡ í•œë‹¤.
			float NewTransparency = FMath::Max(CurrentTransparency - InDissolve * SpeedMultiplier, 0.0f); // Max í•¨ìˆ˜ëŠ” ì²« ë²ˆì§¸ ì¸ìì˜ ê°’ì´ ìŒìˆ˜ê°€ ë‚˜ì˜¤ë©´ 0.0fì„ ë°˜í™˜í•´ ì¤€ë‹¤.
			MaterialInstanceDynamics->SetScalarParameterValue(FName("Opacity"), NewTransparency);
		}
	}
	
	void ADefaultMonster::OnDisappearMeshEnd()
	{
		Destroy();
	}
	```
	</details>

---

### ğŸ–¥ï¸ UI
  - Player ì‚¬ë§ ì‹œ ë¦¬ìŠ¤í°ì°½ ì¶œë ¥ ë° ë¦¬ìŠ¤í° ì§„í–‰
                                <br><br>
![deathAndRespawn](https://github.com/user-attachments/assets/8f044cc1-90b6-4b21-a080-380afc884a2f)

---

### ğŸ“Š ë°ì´í„° ê´€ë¦¬
  * **Playerì˜ ë°ì´í„°**ëŠ” ì–¸ë¦¬ì–¼ ì—”ì§„ ì—ë””í„°ìƒì—ì„œ ë°ì´í„° í…Œì´ë¸”ë¡œ ì„¸íŒ… ê°€ëŠ¥
          <br><br>
  ![alt text](README_content/pawndata.png "Title Text")<br>  ã€€ã€€ã€€ã€€ã€€ã€€  ã€€ã€€ã€€ã€€ã€€ã€€  ã€€ã€€ã€€ã€€ã€€ã€€ã€€**`Player ë°ì´í„° í…Œì´ë¸”`**<br>
	  
  * **Weaponì˜ ë°ì´í„°**ëŠ” ì–¸ë¦¬ì–¼ ì—”ì§„ ì—ë””í„°ìƒì—ì„œ ë°ì´í„° í…Œì´ë¸”ë¡œ ì„¸íŒ… ê°€ëŠ¥
    <br>
**Weapon ë°ì´í„° í…Œì´ë¸”**ì—ì„œëŠ” í•´ë‹¹ Weaponì´ ë³´ìœ í•  Skillì„ ì„¸íŒ…í•´ ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br><br>
![alt text](README_content/WeaponTable.png "Title Text")<br>  ã€€ã€€ã€€ã€€ã€€ã€€  ã€€ã€€ã€€ã€€ã€€ã€€  **`Weapon ë°ì´í„° í…Œì´ë¸”`**<br><br><br>
**Skill ë°ì´í„° í…Œì´ë¸”**ì—ì„œëŠ” í•´ë‹¹ Skill ì‚¬ìš© ì‹œ ë°œì‚¬ë˜ëŠ” Projectileì„ ì„¸íŒ…í•´ ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br><br> ![alt text](README_content/SkillTable.png "Title Text")<br>  ã€€ã€€ã€€ã€€ã€€ã€€  ã€€ã€€ã€€ã€€ã€€ã€€  **`Skill ë°ì´í„° í…Œì´ë¸”`**<br><br>
**Projectile ë°ì´í„° í…Œì´ë¸”**ì—ì„œëŠ” í•´ë‹¹ Projectileì˜ í¬ê¸°ì™€ ìŠ¤í° ìœ„ì¹˜ë¥¼ ì„¸íŒ…í•´ ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br><br> ![alt text](README_content/ProjectileTable.png "Title Text")<br>  ã€€ã€€ã€€ã€€ã€€ã€€  ã€€ã€€ã€€ã€€ã€€ã€€  **`Projectile ë°ì´í„° í…Œì´ë¸”`**<br><br>
**Effect ë°ì´í„° í…Œì´ë¸”**ì—ì„œëŠ” Projectileì˜ íš¨ê³¼ìŒê³¼ Effectë¥¼ ì„¸íŒ…í•´ ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br><br> ![alt text](README_content/EffectTable.png "Title Text")<br>  ã€€ã€€ã€€ã€€ã€€ã€€  ã€€ã€€ã€€ã€€ã€€ã€€    ã€€ã€€ã€€**`Effect ë°ì´í„° í…Œì´ë¸”`**<br>

---

## ğŸ“ ì°¸ê³  ì‚¬í•­
- ë¹Œë“œ/ì‹¤í–‰ ì˜¤ë¥˜ ë°œìƒ ì‹œ Content ê²½ë¡œ í™•ì¸ í•„ìˆ˜
  
---

ğŸ§© íšŒê³ 
- **ë°ì´í„° ê¸°ë°˜ ì„¤ê³„ ê²½í—˜**
ë°œì‚¬ì²´, ë¬´ê¸°, ìŠ¤í‚¬, ì´í™íŠ¸ ë“± ê²Œì„ì˜ ì£¼ìš” ìš”ì†Œë¥¼ DataTableë¡œ ê´€ë¦¬í•˜ë©° í•˜ë“œì½”ë”©ì„ ìµœì†Œí™”í•˜ê³ , ìƒˆë¡œìš´ ë°ì´í„° ì¶”ê°€ì™€ ìˆ˜ì •ì´ ë§¤ìš° í¸ë¦¬í•œ êµ¬ì¡°ë¥¼ ì§ì ‘ ì„¤ê³„í•˜ê³  êµ¬í˜„í•´ë³¼ ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤. ì´ë¥¼ í†µí•´ í™•ì¥ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì˜ ì¤‘ìš”ì„±ì„ ì²´ê°í–ˆìŠµë‹ˆë‹¤.

- **íŠ¸ëŸ¬ë¸”ìŠˆíŒ… ì—­ëŸ‰ ê°•í™”**
ë°œì‚¬ì²´ ì¶”ì  ë¡œì§, ë¨¸í‹°ë¦¬ì–¼ ë¸”ë Œë”© ë“±ì—ì„œ ë‹¤ì–‘í•œ ë¬¸ì œë¥¼ ì§ì ‘ í•´ê²°í•˜ë©´ì„œ ë¬¸ì œ ë¶„ì„ë ¥ê³¼ ë””ë²„ê¹… ì‹¤ë ¥ì´ í¬ê²Œ ì„±ì¥í–ˆë‹¤ê³  ëŠê¼ˆìŠµë‹ˆë‹¤.

- **ê°œì¸ í”„ë¡œì íŠ¸ì˜ ì£¼ë„ì  ì™„ì„±**
ì„¤ê³„, êµ¬í˜„, í…ŒìŠ¤íŠ¸ ë° ë””ë²„ê¹…, ë¬¸ì„œí™”ê¹Œì§€ ëª¨ë“  ê³¼ì •ì„ ìŠ¤ìŠ¤ë¡œ ì£¼ë„ì ìœ¼ë¡œ ì§„í–‰í•˜ë©° ì‹¤ë¬´ì™€ ìœ ì‚¬í•œ ê²½í—˜ì„ ìŒ“ì•˜ê³ , ìì‹ ê°ë„ ë†’ì•„ì¡ŒìŠµë‹ˆë‹¤.

- **í–¥í›„ ëª©í‘œ**
ì•ìœ¼ë¡œëŠ” ë©€í‹°í”Œë ˆì´, ë” ë‹¤ì–‘í•œ ì½˜í…ì¸  ì¶”ê°€ ë“± í•œ ë‹¨ê³„ ë†’ì€ ë‚œì´ë„ì˜ ì‹œìŠ¤í…œì—ë„ ë„ì „í•˜ê³  ì‹¶ìŠµë‹ˆë‹¤.

---

### âœ‰ï¸ Contact

- ì´ë©”ì¼ : uoipoip@gmail.com
- GitHub : [WJMcode/Project_CavesBasic](https://github.com/WJMcode/Project_CavesBasic)

---

